= ワイ「ち、チノちゃん！バ○スタのHackしないで！」
@<author>{街の国際ウィザード・バリスター, lrks;twitter}
//lead{
数週間前、念願の同人誌即売会に当選したのだが、『技術力が注目されないなら奇行に走るしかないのでは』という懸念の声があり、結果、あのコピペを改変してネスカフェバリスタの解析記事を書くことになった。
この記事では、バリスタ内部で利用されるI2CバスとBluetoothそれぞれの通信内容を調べ、外部からの操作やHTCPCPの実装を行なっているのだが、なかなか思い通りにいかない場面もあって心イタイイタイなのだった。
//}

TODO: 元コピペをもう一度精査する


== チノ「はじめにですね……」
//noindent
―― ある日の喫茶・ラビットハウスにて ――
チノ「働き方改革の一環で、低価格帯のメニューはインスタントコーヒーを使うことになりました。生産性向上が目的なので、インスタントコーヒーをいれるための専用マシンを使いましょう。」
ワイ「あらかじめ用意しておいたのが、@<img>{pm9631}に示す『ネスカフェバリスタPM9631』と@<img>{barista-i}の『ネスカフェバリスタアイ』になります。」
//subfig[ラビットハウスに導入されたバリスタ]{
//image[pm9631][PM9631][scale=0.3]
//image[barista-i][バリスタアイ][scale=0.3]
//}
チノ「お客様に気付かれないよう、コーヒーを淹れているふりをしてバリスタを使わなければなりません。」
ワイ「難しそうだね…。」
チノ「そこでOpenPoseか何かで動作を検知し、それをトリガーにバリスタを人の手を介さずに操作することにします。」
ワイ「え、そんなことできるの！？」
チノ「OpenPoseはともかく、バリスタを電子的に操作することはできます。次章ではPM9631の操作、またその次ではバリスタアイの操作、そして最後に応用編としてHTCPCPの実装を行います。」


== ワイ「PM9631の操作？」
ワイ「チノちゃん、バリスタを電子的に操作って本当にできるの？」
チノ「ではまず、PM9631を例にして説明します。PM9631には6つの物理ボタンがあり、ソレノイドやサーボモータのようなアクチュエータを用いれば操作できそうです。」
ワイ「アクチュエータで物理的にボタンを押す、そのアクチュエータはプログラムから操作するということだね。」
チノ「そのとおりです。でもそれってクールといえるでしょうか？」
？？「自分の両親がアクチュエータでバリスタを操作してたらどう思う？」
ワイ「どうも思わないと思います……」
？？「あなたの感覚はおかしいよ」
チノ「というわけで、それよりはマシな方法でバリスタを操作します。バリスタを分解してのパネル基板を見てみましょう。」
ワイ「メイン基板に繋がっているパネルだけの基板…@<img>{panel}だね。ボタンの場所に電極っぽいのがあるけど…？」
//image[panel][PM9631のパネル基板][scale=1]
チノ「この電極をトランジスタか何かで短絡、すなわち『押したことにする』ことはできそうですね。では、あとはお願いします。」
ワイ「分かった！出来たよ！@<fn>{nikkei}」
//footnote[nikkei][@<href>{https://tech.nikkeibp.co.jp/it/atcl/column/16/121900307/122800029/}]
？？「自分の両親がそんな単純な方法でバリスタを操作してたらどう思う？」
ワイ「どうも思わないと思います……」
？？「あなたの感覚はおかしいよ」
チノ「というわけで、それよりはマシな方法として、I2Cでバリスタを操作します。」

=== ワイ「I2Cで操作？」
チノ「バリスタのパネル基板をよく見てください。@<img>{assign}のように@<b>{+5V}・@<b>{IRQ}・@<b>{GND}・@<b>{SDA}・@<b>{SCL}というシルク印刷が見えますよね？」
//image[assign][パネル基板の拡大画像][scale=0.5]
ワイ「あ、ほんとだ！この線を通じてメイン基板と通信しているということだね。SDA (TODO:SerialData)とSCL(Todo:Serial Clock)とくればI2C@<fn>{i2c}だ！」
//footnote[i2c][2本の線で信号を伝えるシリアルバス。機器内部のバスとして非常によく使われる。]
チノ「実際、パネルを手で押した際にメイン基板との通信をロジックアナライザで見てみると、@<img>{turnoff}のようにI2Cの通信としてデコードできました。」
//imagew[turnoff][パネル基板メイン基板との通信][scale=1]
ワイ「じゃあパネル基板のふりをして、I2C経由でボタンを押したメッセージを送ればバリスタを操作できそうだね。でも、I2Cってマスターとスレーブという役割があるんじゃなかった？パネル基板はどっちだろう？」
チノ「@<img>{assign}には@<b>{IRQ}という線もありました。割り込み要求（Interrupt Request/Todo: Interrupt Queue?）のことでしょう。そして、分かりにくいかも知れませんが@<img>{turnoff}ではIRQがLOWになった瞬間にI2Cの通信が始まっています。パネル基板がIRQをLOWに落として、それをメイン基板が検知してI2C通信を始めた可能性が高いでしょう。」
ワイ「I2Cでの通信はすべてマスターから始まる、もしパネル基板がマスターならわざわざIRQをLOWに落とす必要はないね。」
チノ「すなわちパネル基板はI2Cスレーブ、なので今回はI2Cスレーブとしてパネル基板に成りすます何かを作れば良いですね。」
ワイ「スレーブか…。受け側を作るのはなかなかツライツライだね…。」
チノ「何でも受けのほうが大変ですからね。」

=== ワイ「これが本当のI2Cの通信内容です！」
チノ「I2Cスレーブになりすますにあたって、まずはI2Cの通信内容を調べたいと思います。ボタンを押してロジアナで記録するだけなので、あとはよろしくお願いします。」
ワイ「はい……」
//noindent
―― 数日後 ――
ワイ「できたよ！フローチャート（図TODO）が！」
チノ「でかしました！図中のボタンIDって何ですか？」
ワイ「電源ボタンとかのIDだよ！具体的な値は表TODOにあるよ！！」
チノ「分かりました。あと途中で水タンクが空になった場合、操作パネルのLEDが光りますがどういった通信になりますか？ボタンは押していないのでIRQをつかむといった操作は発生しないと思いますが。」
ワイ「図TODOにおける最後の通信、Write~~~だけ発生するよ。おそらく特定レジスタの状態（表TODO）に応じてLEDを光らせていると思う。」
チノ「拝承しました。こちらでも軽く見てみると、ときどき@<tt>{0x80}をデータとするWriteと直後のRead、それに対する@<tt>{0x07}の返送もありますね。発生のタイミングは不明ですが、パネル基板のバージョンを確認しているのかも知れませんね。」

=== ワイ「なれる！Slave」
チノ「ということで、スレーブになってください。ここにLPC1114@<fn>{lpc1114}を用意しました。」
//footnote[lpc1114][ARMアーキテクチャで動くマイコン。初稿執筆時点ではメーカーのセールが行われており、価格が安い割に扱いやすく人気があった。]
チノ「スレーブになるのは得意だから任せて！」
//noindent
―― 半年後 ――
ワイ「なったよ！スレーブに！@<fn>{slave}」
//footnote[slave][TODO:githubの]
チノ「ちょっと遅かったんじゃないですか？」
ワイ「まだ見習いなんで……メイン基板がクロックストレッチを考慮してないっぽくて苦労してたんだ。」
チノ「クロックストレッチ？」
ワイ「スレーブ側がSCLをLOWに落とすことで、マスターに『ま、マスターちゃん！SDA激しくしないで！（データの送信をやめて）』って伝えるための機能だよ。I2Cのオプション機能だから対応しなくても良いんだけどね。」
チノ「それに対応していないと、どうなるんですか？」
ワイ「マスターは『スレーブは必ず受け止めてくれる(TODO:あの表現に直す)』と思っているので、本当はデータをWriteしていないのに書けた気になったり、誤ったデータを読み出してしまう。」
チノ「大変ですね。でも、LPC1114のスレーブってそんなに遅いんですか？クロックストレッチしないといけない程度に？」
ワイ「実はデバッグ用にUARTでログを流していて。それを消したらクロックストレッチの必要がなくなったよ。」
チノ「えぇ……。」


== チノ「バリスタアイの操作」
チノ「次はバリスタアイについてです。BLE (Bluetooth Low Energy)で接続でき、ネスカフェが提供する専用のiOS/Androidアプリから操作できます。」
ワイ「じゃあそれでいいんじゃないの？」
？？「自分の親が公式アプリを使ってバリスタアイを操作してたらどう思う？」
ワイ「どうも思わないと思います……」
？？「あなたの感覚はおかしいよ」
チノ「というわけで、それよりはマシな方法でバリスタアイを操作します。」

=== ワイ「Bluetoothのスニファリング」
チノ「まず公式アプリとバリスタアイの通信内容を見ましょう。うちに出入りするのは女子中高生が中心のためAndroid端末がありません。iOS端末で見ていきます。」
ワイ「iOS端末でやるのは大変じゃない？脱獄することになるんじゃ？」
チノ「なので、端末やアプリには手を加えず、あのBluetoothスニファを利用します。」
ワイ「Adafruitやスイッチサイエンスで売られているTODO:型番だね。技適はないけど、受信専用なので日本国内で使っても大丈夫ということになっているやつ。」
チノ「依存するWiresharkのバージョンが(todo)だったりして少し古いですが、使い方は簡単です。todoのような結果が取れます。」
ワイ「じゃあこの通信の流れを実装すれば良さそうだね。@<tt>{gatttool}（後述）で試してみるよ。」
チノ「お願いします。」
―― 数日後 ――
ワイ「動かない。」
チノ「悲しいですね……」
―― さらに数日後 ――
ワイ「todoで使っていたコーヒーメーカー、あれバリスタアイだよね。」
チノ「そうなんですか？」
ワイ「著者がTwitterに書いているし、文章中のuuidがバリスタアイのそれなんだよね。」
チノ「この本には、認証なしでコーヒーを入れられたことが書かれていますね。ちょっと本に紹介されているコマンドを実行してみます。」
ワイ「お願いします。」
―― 数日後 ――
チノ「動かないですね。」
ワイ「悲しいですね……」

=== ワイ「Androidアプリの解析？」
チノ「どうにも動かないので、別のアプローチを取りましょう。アプリを解析して通信の流れを追います。」
ワイ「Android版だとapkという名のソースコードが手に入る@<fn>{apk}から、そっちを解析してみよう。」
//footnote[apk][当然ながらapk(todo略語)はソースコードではない。]
チノ「見たところ、FOTA@<fn>{fota}の機能も備えているようです。思ったより本格的ですね。そして気になるのが関数名に@<tt>{encryptedFW}(todo)が付いているものといないもの、そして『lightpairing』というキーワードが頻出することです。」
ワイ「lightpairing？そういえば公式アプリとバリスタアイを初めてリンクさせるとき、ペアリングがなんとかって言われたような……。」
チノ「そうですか。では、あとはお願いします。」

=== チノ「これが本当のBLEの通信内容です！」
ワイ「調べ終わったよ。結果からいえば『バリスタアイにはFWバージョンが複数あると推察する』『少なくとも手元のSP07というバージョンにおいては、暗号化されたメッセージを送らないとコーヒーを入れられない』『暗号化に必要な鍵はlightpairingを通じて取得する』っぽいよ。」
チノ「大変そうですね。BLEで接続してコーヒーを入れるまでの流れはどうなっていますか？」
ワイ「todoに示すよ。todoに示すボタンを押すことで入れることを想定している。」
チノ「これlightpairingが盗聴されたら暗号化の意味無くなりますよね。それと公式アプリでは、水の量やコーヒーの量を調整して入れられるようなカスタムレシピ機能がありましたよね？それを使う方法でもコーヒーをいれられそうですが。」
ワイ「分かりませんでした……。」
チノ「えぇ……。」
ワイ「ちなみに、小ネタとしてBLEのリンクを示すLEDも制御できるっぽいよ。todoで。」

=== チノ「CLIから操作」

操作してみますね













ここにESP-WROOM-02@<fn>{esp8266}を用意しました。」
//footnote[esp8266][技適の通ったWi-Fiが使えるマイコンモジュール。TODO円と安価で初稿執筆時点では珍しかった。]
ワイ「スレーブになるのは得意だから任せて！でも、ESP-WROOM-02にハードウェアでI2Cスレーブになる機能はないね…マスターならまだしもスレーブのソフトウェア実装は嫌だよ……。」
チノ「しょうがないですね……ここにLPC1114を用意しました。」

ワイ「これだとハードウェア的にI2Cスレーブが扱えるね！ESP-WROOM-02とLPC1114をUARTで

ESP-WROOM-02をメイン」




























== おわりに
くぅ〜疲れましたw
元コピペ暗唱できる
